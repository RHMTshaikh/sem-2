{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from minisom import MiniSom\n",
    "\n",
    "from sklearn.datasets import load_iris\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "\n",
    "import math\n",
    "import numpy as np\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "iris = load_iris()\n",
    "features = iris.data\n",
    "labels = iris.target\n",
    "\n",
    "print(features[0])\n",
    "\n",
    "sc = MinMaxScaler(feature_range = (0,1))\n",
    "features = sc.fit_transform(features)\n",
    "\n",
    "sigma = 1.5\n",
    "lr = 0.5\n",
    "n_features = features.shape[1]\n",
    "n_samples = features.shape[0]\n",
    "\n",
    "map_size = 5 * math.sqrt(n_samples)\n",
    "map_height = map_width = math.ceil(math.sqrt(map_size))\n",
    "\n",
    "\n",
    "print(f'(map_height, map_width) = ({map_height}, {map_width})')\n",
    "print(f'Number of features: {n_features}')\n",
    "\n",
    "som = MiniSom(x=map_height, y=map_width, input_len=n_features, sigma=sigma, learning_rate=lr,\n",
    "              neighborhood_function='gaussian', random_seed=123)\n",
    "\n",
    "som.pca_weights_init(features)\n",
    "som.train(data=features, num_iteration=1000, verbose=True)  # random training\n",
    "\n",
    "print('-------------\\nDistance Map\\n------------')\n",
    "print(f'Shape: {som.distance_map().shape}')\n",
    "print(f'First Line: {som.distance_map().T[0]}')\n",
    "\n",
    "frequencies = som.activation_response(features)\n",
    "print(f'Frequencies:\\n {np.array(frequencies, np.uint)}')\n",
    "\n",
    "print(iris.target_names)\n",
    "\n",
    "plt.figure(figsize=(map_height, map_width))\n",
    "\n",
    "# plot U-matrix\n",
    "u_matrix = som.distance_map().T\n",
    "plt.pcolor(u_matrix, cmap='bone_r')\n",
    "plt.colorbar()\n",
    "\n",
    "# plot markers\n",
    "markers = ['o', 's', '^']   # 'setosa', 'versicolor' 'virginica'\n",
    "colors = ['r', 'g', 'b']\n",
    "for feature, label in zip(features, labels):\n",
    "    w = som.winner(feature)\n",
    "    plt.plot(w[0] + 0.5, w[1] + 0.5,\n",
    "        markers[label], markeredgecolor = colors[label],\n",
    "        markerfacecolor = 'None', markersize = 10, markeredgewidth = 1)\n",
    "\n",
    "plt.show()\n",
    "\n",
    "def plot_distance_map(ax, fig):\n",
    "    \"\"\"Plot the distance map\"\"\"\n",
    "    p = ax.pcolor(som.distance_map().T, cmap='bone_r') # cmap='Blues'\n",
    "    # ax.colorbar()\n",
    "    fig.colorbar(p, ax=ax)\n",
    "\n",
    "def plot_clusters_scatter(ax):\n",
    "    \"\"\"\n",
    "    Create a scatter plot of the winning neurons.\n",
    "    Each neuron is assigned the color of the cluster it belongs to.\n",
    "    \"\"\"\n",
    "    # Get the winning neuron coordinates for each sample\n",
    "    # The coordinates are transformed into an array for the scatter plot: (1,1) => [1,1]\n",
    "    winning_neurons = np.array([som.winner(x) for x in features])\n",
    "\n",
    "    # Add a random offset to avoid overlaps between points within the same cell\n",
    "    offset = np.random.uniform(low=-0.4, high=0.4, size=(len(features), 2))\n",
    "    winning_neurons = winning_neurons + offset\n",
    "\n",
    "    # Define the colors based on the labels\n",
    "    colors = ['#ff0400', 'g', '#e88325']\n",
    "    label_colors = [colors[label] for label in labels]\n",
    "\n",
    "    # Create the scatter plot\n",
    "    # 1st column represent x and second, y coordinate\n",
    "    ax.scatter(winning_neurons[:,0], winning_neurons[:,1], s=10, c=label_colors)\n",
    "\n",
    "def plot_clusters_markers(ax):\n",
    "    \"\"\"\n",
    "    Plot the winning neurons as markers.\n",
    "    Each marker is assigned the color of the cluster ir belongs to.\n",
    "    \"\"\"\n",
    "    markers = ['o', 's', '^']\n",
    "    colors = ['#ff0400', 'g', '#e88325']\n",
    "    for i, feature in enumerate(features):\n",
    "        w = som.winner(feature)\n",
    "        ax.plot(w[0] + 0.5, w[1] + 0.5,\n",
    "            markers[labels[i]], markeredgecolor = colors[labels[i]],\n",
    "            markerfacecolor = 'None', markersize = 10, markeredgewidth = 1)\n",
    "\n",
    "    # legend\n",
    "    ax.legend(handles=[plt.Line2D([], [], color='#ff0400', marker='o', linestyle='None', label='Setosa'),\n",
    "                    plt.Line2D([], [], color='green', marker='s', linestyle='None', label='Versicolor'),\n",
    "                    plt.Line2D([], [], color='#e88325', marker='^', linestyle='None', label='Virginica')],\n",
    "                    bbox_to_anchor=(1.5, 1.03))\n",
    "\n",
    "fig, axes = plt.subplots(1, 3, figsize=(12, 4))\n",
    "\n",
    "plot_distance_map(axes[0], fig)\n",
    "plot_clusters_scatter(axes[1])\n",
    "plot_clusters_markers(axes[2])\n",
    "\n",
    "plt.suptitle(\"Plants species clusters\")\n",
    "plt.show()\n",
    "\n",
    "plt.figure(figsize=(5, 4))\n",
    "\n",
    "frequencies = som.activation_response(features)\n",
    "plt.pcolor(frequencies.T, cmap='Blues')\n",
    "plt.colorbar()\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
